/*!
 * Flickity PACKAGED v2.3.0
 * Touch, responsive, flickable carousels
 *
 * Licensed GPLv3 for open source use
 * or Flickity Commercial License for commercial use
 *
 * https://flickity.metafizzy.co
 * Copyright 2015-2021 Metafizzy
 */
(function (e, i) { if (typeof define === "function" && define.amd) { define("jquery-bridget/jquery-bridget", ["jquery"], function (t) { return i(e, t); }); } else if (typeof module === "object" && module.exports) { module.exports = i(e, require("jquery")); } else { e.jQueryBridget = i(e, e.jQuery); } })(window, function t (e, r) { "use strict"; const o = Array.prototype.slice; const i = e.console; const u = typeof i === "undefined" ? function () {} : function (t) { i.error(t); }; function n (h, s, c) { c = c || r || e.jQuery; if (!c) { return; } if (!s.prototype.option) { s.prototype.option = function (t) { if (!c.isPlainObject(t)) { return; } this.options = c.extend(true, this.options, t); }; }c.fn[h] = function (t) { if (typeof t === "string") { const e = o.call(arguments, 1); return i(this, t, e); }n(this, t); return this; }; function i (t, r, o) { let a; const l = "$()." + h + '("' + r + '")'; t.each(function (t, e) { const i = c.data(e, h); if (!i) { u(h + " not initialized. Cannot call methods, i.e. " + l); return; } const n = i[r]; if (!n || r.charAt(0) == "_") { u(l + " is not a valid method"); return; } const s = n.apply(i, o); a = a === undefined ? s : a; }); return a !== undefined ? a : t; } function n (t, n) { t.each(function (t, e) { let i = c.data(e, h); if (i) { i.option(n); i._init(); } else { i = new s(e, n); c.data(e, h, i); } }); }a(c); } function a (t) { if (!t || t && t.bridget) { return; }t.bridget = n; }a(r || e.jQuery); return n; }); (function (t, e) { if (typeof define === "function" && define.amd) { define("ev-emitter/ev-emitter", e); } else if (typeof module === "object" && module.exports) { module.exports = e(); } else { t.EvEmitter = e(); } })(typeof window !== "undefined" ? window : this, function () { function t () {} const e = t.prototype; e.on = function (t, e) { if (!t || !e) { return; } const i = this._events = this._events || {}; const n = i[t] = i[t] || []; if (n.indexOf(e) == -1) { n.push(e); } return this; }; e.once = function (t, e) { if (!t || !e) { return; } this.on(t, e); const i = this._onceEvents = this._onceEvents || {}; const n = i[t] = i[t] || {}; n[e] = true; return this; }; e.off = function (t, e) { const i = this._events && this._events[t]; if (!i || !i.length) { return; } const n = i.indexOf(e); if (n != -1) { i.splice(n, 1); } return this; }; e.emitEvent = function (t, e) { let i = this._events && this._events[t]; if (!i || !i.length) { return; }i = i.slice(0); e = e || []; const n = this._onceEvents && this._onceEvents[t]; for (let s = 0; s < i.length; s++) { const r = i[s]; const o = n && n[r]; if (o) { this.off(t, r); delete n[r]; }r.apply(this, e); } return this; }; e.allOff = function () { delete this._events; delete this._onceEvents; }; return t; });
/*!
 * getSize v2.0.3
 * measure size of elements
 * MIT license
 */
(function (t, e) { if (typeof define === "function" && define.amd) { define("get-size/get-size", e); } else if (typeof module === "object" && module.exports) { module.exports = e(); } else { t.getSize = e(); } })(window, function t () { "use strict"; function m (t) { const e = parseFloat(t); const i = t.indexOf("%") == -1 && !isNaN(e); return i && e; } function e () {} const i = typeof console === "undefined" ? e : function (t) { console.error(t); }; const y = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"]; const b = y.length; function E () { const t = { width: 0, height: 0, innerWidth: 0, innerHeight: 0, outerWidth: 0, outerHeight: 0 }; for (let e = 0; e < b; e++) { const i = y[e]; t[i] = 0; } return t; } function S (t) { const e = getComputedStyle(t); if (!e) { i("Style returned " + e + ". Are you running this code in a hidden iframe on Firefox? " + "See https://bit.ly/getsizebug1"); } return e; } let n = false; let C; function x () { if (n) { return; }n = true; const t = document.createElement("div"); t.style.width = "200px"; t.style.padding = "1px 2px 3px 4px"; t.style.borderStyle = "solid"; t.style.borderWidth = "1px 2px 3px 4px"; t.style.boxSizing = "border-box"; const e = document.body || document.documentElement; e.appendChild(t); const i = S(t); C = Math.round(m(i.width)) == 200; s.isBoxSizeOuter = C; e.removeChild(t); } function s (t) { x(); if (typeof t === "string") { t = document.querySelector(t); } if (!t || typeof t !== "object" || !t.nodeType) { return; } const e = S(t); if (e.display == "none") { return E(); } const i = {}; i.width = t.offsetWidth; i.height = t.offsetHeight; const n = i.isBorderBox = e.boxSizing == "border-box"; for (let s = 0; s < b; s++) { const r = y[s]; const o = e[r]; const a = parseFloat(o); i[r] = !isNaN(a) ? a : 0; } const l = i.paddingLeft + i.paddingRight; const h = i.paddingTop + i.paddingBottom; const c = i.marginLeft + i.marginRight; const u = i.marginTop + i.marginBottom; const d = i.borderLeftWidth + i.borderRightWidth; const f = i.borderTopWidth + i.borderBottomWidth; const p = n && C; const v = m(e.width); if (v !== false) { i.width = v + (p ? 0 : l + d); } const g = m(e.height); if (g !== false) { i.height = g + (p ? 0 : h + f); }i.innerWidth = i.width - (l + d); i.innerHeight = i.height - (h + f); i.outerWidth = i.width + c; i.outerHeight = i.height + u; return i; } return s; }); (function (t, e) { "use strict"; if (typeof define === "function" && define.amd) { define("desandro-matches-selector/matches-selector", e); } else if (typeof module === "object" && module.exports) { module.exports = e(); } else { t.matchesSelector = e(); } })(window, function t () { "use strict"; const n = (function () { const t = window.Element.prototype; if (t.matches) { return "matches"; } if (t.matchesSelector) { return "matchesSelector"; } const e = ["webkit", "moz", "ms", "o"]; for (let i = 0; i < e.length; i++) { const n = e[i]; const s = n + "MatchesSelector"; if (t[s]) { return s; } } }()); return function t (e, i) { return e[n](i); }; }); (function (e, i) { if (typeof define === "function" && define.amd) { define("fizzy-ui-utils/utils", ["desandro-matches-selector/matches-selector"], function (t) { return i(e, t); }); } else if (typeof module === "object" && module.exports) { module.exports = i(e, require("desandro-matches-selector")); } else { e.fizzyUIUtils = i(e, e.matchesSelector); } })(window, function t (h, r) { const c = {}; c.extend = function (t, e) { for (const i in e) { t[i] = e[i]; } return t; }; c.modulo = function (t, e) { return (t % e + e) % e; }; const i = Array.prototype.slice; c.makeArray = function (t) { if (Array.isArray(t)) { return t; } if (t === null || t === undefined) { return []; } const e = typeof t === "object" && typeof t.length === "number"; if (e) { return i.call(t); } return [t]; }; c.removeFrom = function (t, e) { const i = t.indexOf(e); if (i != -1) { t.splice(i, 1); } }; c.getParent = function (t, e) { while (t.parentNode && t != document.body) { t = t.parentNode; if (r(t, e)) { return t; } } }; c.getQueryElement = function (t) { if (typeof t === "string") { return document.querySelector(t); } return t; }; c.handleEvent = function (t) { const e = "on" + t.type; if (this[e]) { this[e](t); } }; c.filterFindElements = function (t, n) { t = c.makeArray(t); const s = []; t.forEach(function (t) { if (!(t instanceof HTMLElement)) { return; } if (!n) { s.push(t); return; } if (r(t, n)) { s.push(t); } const e = t.querySelectorAll(n); for (let i = 0; i < e.length; i++) { s.push(e[i]); } }); return s; }; c.debounceMethod = function (t, e, n) { n = n || 100; const s = t.prototype[e]; const r = e + "Timeout"; t.prototype[e] = function () { const t = this[r]; clearTimeout(t); const e = arguments; const i = this; this[r] = setTimeout(function () { s.apply(i, e); delete i[r]; }, n); }; }; c.docReady = function (t) { const e = document.readyState; if (e == "complete" || e == "interactive") { setTimeout(t); } else { document.addEventListener("DOMContentLoaded", t); } }; c.toDashed = function (t) { return t.replace(/(.)([A-Z])/g, function (t, e, i) { return e + "-" + i; }).toLowerCase(); }; const u = h.console; c.htmlInit = function (a, l) { c.docReady(function () { const t = c.toDashed(l); const s = "data-" + t; const e = document.querySelectorAll("[" + s + "]"); const i = document.querySelectorAll(".js-" + t); const n = c.makeArray(e).concat(c.makeArray(i)); const r = s + "-options"; const o = h.jQuery; n.forEach(function (e) { const t = e.getAttribute(s) || e.getAttribute(r); let i; try { i = t && JSON.parse(t); } catch (t) { if (u) { u.error("Error parsing " + s + " on " + e.className + ": " + t); } return; } const n = new a(e, i); if (o) { o.data(e, l, n); } }); }); }; return c; }); (function (e, i) { if (typeof define === "function" && define.amd) { define("flickity/js/cell", ["get-size/get-size"], function (t) { return i(e, t); }); } else if (typeof module === "object" && module.exports) { module.exports = i(e, require("get-size")); } else { e.Flickity = e.Flickity || {}; e.Flickity.Cell = i(e, e.getSize); } })(window, function t (e, i) { function n (t, e) { this.element = t; this.parent = e; this.create(); } const s = n.prototype; s.create = function () { this.element.style.position = "absolute"; this.element.setAttribute("aria-hidden", "true"); this.x = 0; this.shift = 0; this.element.style[this.parent.originSide] = 0; }; s.destroy = function () { this.unselect(); this.element.style.position = ""; const t = this.parent.originSide; this.element.style[t] = ""; this.element.style.transform = ""; this.element.removeAttribute("aria-hidden"); }; s.getSize = function () { this.size = i(this.element); }; s.setPosition = function (t) { this.x = t; this.updateTarget(); this.renderPosition(t); }; s.updateTarget = s.setDefaultTarget = function () { const t = this.parent.originSide == "left" ? "marginLeft" : "marginRight"; this.target = this.x + this.size[t] + this.size.width * this.parent.cellAlign; }; s.renderPosition = function (t) { const e = this.parent.originSide === "left" ? 1 : -1; const i = this.parent.options.percentPosition ? t * e * (this.parent.size.innerWidth / this.size.width) : t * e; this.element.style.transform = "translateX(" + this.parent.getPositionValue(i) + ")"; }; s.select = function () { this.element.classList.add("is-selected"); this.element.removeAttribute("aria-hidden"); }; s.unselect = function () { this.element.classList.remove("is-selected"); this.element.setAttribute("aria-hidden", "true"); }; s.wrapShift = function (t) { this.shift = t; this.renderPosition(this.x + this.parent.slideableWidth * t); }; s.remove = function () { this.element.parentNode.removeChild(this.element); }; return n; }); (function (t, e) { if (typeof define === "function" && define.amd) { define("flickity/js/slide", e); } else if (typeof module === "object" && module.exports) { module.exports = e(); } else { t.Flickity = t.Flickity || {}; t.Flickity.Slide = e(); } })(window, function t () { "use strict"; function e (t) { this.parent = t; this.isOriginLeft = t.originSide == "left"; this.cells = []; this.outerWidth = 0; this.height = 0; } const i = e.prototype; i.addCell = function (t) { this.cells.push(t); this.outerWidth += t.size.outerWidth; this.height = Math.max(t.size.outerHeight, this.height); if (this.cells.length == 1) { this.x = t.x; const e = this.isOriginLeft ? "marginLeft" : "marginRight"; this.firstMargin = t.size[e]; } }; i.updateTarget = function () { const t = this.isOriginLeft ? "marginRight" : "marginLeft"; const e = this.getLastCell(); const i = e ? e.size[t] : 0; const n = this.outerWidth - (this.firstMargin + i); this.target = this.x + this.firstMargin + n * this.parent.cellAlign; }; i.getLastCell = function () { return this.cells[this.cells.length - 1]; }; i.select = function () { this.cells.forEach(function (t) { t.select(); }); }; i.unselect = function () { this.cells.forEach(function (t) { t.unselect(); }); }; i.getCellElements = function () { return this.cells.map(function (t) { return t.element; }); }; return e; }); (function (e, i) { if (typeof define === "function" && define.amd) { define("flickity/js/animate", ["fizzy-ui-utils/utils"], function (t) { return i(e, t); }); } else if (typeof module === "object" && module.exports) { module.exports = i(e, require("fizzy-ui-utils")); } else { e.Flickity = e.Flickity || {}; e.Flickity.animatePrototype = i(e, e.fizzyUIUtils); } })(window, function t (e, i) { const n = {}; n.startAnimation = function () { if (this.isAnimating) { return; } this.isAnimating = true; this.restingFrames = 0; this.animate(); }; n.animate = function () { this.applyDragForce(); this.applySelectedAttraction(); const t = this.x; this.integratePhysics(); this.positionSlider(); this.settle(t); if (this.isAnimating) { const e = this; requestAnimationFrame(function t () { e.animate(); }); } }; n.positionSlider = function () { let t = this.x; if (this.options.wrapAround && this.cells.length > 1) { t = i.modulo(t, this.slideableWidth); t -= this.slideableWidth; this.shiftWrapCells(t); } this.setTranslateX(t, this.isAnimating); this.dispatchScrollEvent(); }; n.setTranslateX = function (t, e) { t += this.cursorPosition; t = this.options.rightToLeft ? -t : t; const i = this.getPositionValue(t); this.slider.style.transform = e ? "translate3d(" + i + ",0,0)" : "translateX(" + i + ")"; }; n.dispatchScrollEvent = function () { const t = this.slides[0]; if (!t) { return; } const e = -this.x - t.target; const i = e / this.slidesWidth; this.dispatchEvent("scroll", null, [i, e]); }; n.positionSliderAtSelected = function () { if (!this.cells.length) { return; } this.x = -this.selectedSlide.target; this.velocity = 0; this.positionSlider(); }; n.getPositionValue = function (t) { if (this.options.percentPosition) { return Math.round(t / this.size.innerWidth * 1e4) * 0.01 + "%"; } else { return Math.round(t) + "px"; } }; n.settle = function (t) { const e = !this.isPointerDown && Math.round(this.x * 100) == Math.round(t * 100); if (e) { this.restingFrames++; } if (this.restingFrames > 2) { this.isAnimating = false; delete this.isFreeScrolling; this.positionSlider(); this.dispatchEvent("settle", null, [this.selectedIndex]); } }; n.shiftWrapCells = function (t) { const e = this.cursorPosition + t; this._shiftCells(this.beforeShiftCells, e, -1); const i = this.size.innerWidth - (t + this.slideableWidth + this.cursorPosition); this._shiftCells(this.afterShiftCells, i, 1); }; n._shiftCells = function (t, e, i) { for (let n = 0; n < t.length; n++) { const s = t[n]; const r = e > 0 ? i : 0; s.wrapShift(r); e -= s.size.outerWidth; } }; n._unshiftCells = function (t) { if (!t || !t.length) { return; } for (let e = 0; e < t.length; e++) { t[e].wrapShift(0); } }; n.integratePhysics = function () { this.x += this.velocity; this.velocity *= this.getFrictionFactor(); }; n.applyForce = function (t) { this.velocity += t; }; n.getFrictionFactor = function () { return 1 - this.options[this.isFreeScrolling ? "freeScrollFriction" : "friction"]; }; n.getRestingPosition = function () { return this.x + this.velocity / (1 - this.getFrictionFactor()); }; n.applyDragForce = function () { if (!this.isDraggable || !this.isPointerDown) { return; } const t = this.dragX - this.x; const e = t - this.velocity; this.applyForce(e); }; n.applySelectedAttraction = function () { const t = this.isDraggable && this.isPointerDown; if (t || this.isFreeScrolling || !this.slides.length) { return; } const e = this.selectedSlide.target * -1 - this.x; const i = e * this.options.selectedAttraction; this.applyForce(i); }; return n; }); (function (o, a) { if (typeof define === "function" && define.amd) { define("flickity/js/flickity", ["ev-emitter/ev-emitter", "get-size/get-size", "fizzy-ui-utils/utils", "./cell", "./slide", "./animate"], function (t, e, i, n, s, r) { return a(o, t, e, i, n, s, r); }); } else if (typeof module === "object" && module.exports) { module.exports = a(o, require("ev-emitter"), require("get-size"), require("fizzy-ui-utils"), require("./cell"), require("./slide"), require("./animate")); } else { const t = o.Flickity; o.Flickity = a(o, o.EvEmitter, o.getSize, o.fizzyUIUtils, t.Cell, t.Slide, t.animatePrototype); } })(window, function t (n, e, i, a, s, o, r) { let l = n.jQuery; const h = n.getComputedStyle; const c = n.console; function u (t, e) { t = a.makeArray(t); while (t.length) { e.appendChild(t.shift()); } } let d = 0; const f = {}; function p (t, e) { const i = a.getQueryElement(t); if (!i) { if (c) { c.error("Bad element for Flickity: " + (i || t)); } return; } this.element = i; if (this.element.flickityGUID) { const n = f[this.element.flickityGUID]; if (n)n.option(e); return n; } if (l) { this.$element = l(this.element); } this.options = a.extend({}, this.constructor.defaults); this.option(e); this._create(); }p.defaults = { accessibility: true, cellAlign: "center", freeScrollFriction: 0.075, friction: 0.28, namespaceJQueryEvents: true, percentPosition: true, resize: true, selectedAttraction: 0.025, setGallerySize: true }; p.createMethods = []; const v = p.prototype; a.extend(v, e.prototype); v._create = function () { const t = this.guid = ++d; this.element.flickityGUID = t; f[t] = this; this.selectedIndex = 0; this.restingFrames = 0; this.x = 0; this.velocity = 0; this.originSide = this.options.rightToLeft ? "right" : "left"; this.viewport = document.createElement("div"); this.viewport.className = "flickity-viewport"; this._createSlider(); if (this.options.resize || this.options.watchCSS) { n.addEventListener("resize", this); } for (const e in this.options.on) { const i = this.options.on[e]; this.on(e, i); }p.createMethods.forEach(function (t) { this[t](); }, this); if (this.options.watchCSS) { this.watchCSS(); } else { this.activate(); } }; v.option = function (t) { a.extend(this.options, t); }; v.activate = function () { if (this.isActive) { return; } this.isActive = true; this.element.classList.add("flickity-enabled"); if (this.options.rightToLeft) { this.element.classList.add("flickity-rtl"); } this.getSize(); const t = this._filterFindCellElements(this.element.children); u(t, this.slider); this.viewport.appendChild(this.slider); this.element.appendChild(this.viewport); this.reloadCells(); if (this.options.accessibility) { this.element.tabIndex = 0; this.element.addEventListener("keydown", this); } this.emitEvent("activate"); this.selectInitialIndex(); this.isInitActivated = true; this.dispatchEvent("ready"); }; v._createSlider = function () { const t = document.createElement("div"); t.className = "flickity-slider"; t.style[this.originSide] = 0; this.slider = t; }; v._filterFindCellElements = function (t) { return a.filterFindElements(t, this.options.cellSelector); }; v.reloadCells = function () { this.cells = this._makeCells(this.slider.children); this.positionCells(); this._getWrapShiftCells(); this.setGallerySize(); }; v._makeCells = function (t) { const e = this._filterFindCellElements(t); const i = e.map(function (t) { return new s(t, this); }, this); return i; }; v.getLastCell = function () { return this.cells[this.cells.length - 1]; }; v.getLastSlide = function () { return this.slides[this.slides.length - 1]; }; v.positionCells = function () { this._sizeCells(this.cells); this._positionCells(0); }; v._positionCells = function (t) { t = t || 0; this.maxCellHeight = t ? this.maxCellHeight || 0 : 0; let e = 0; if (t > 0) { const i = this.cells[t - 1]; e = i.x + i.size.outerWidth; } const n = this.cells.length; for (let s = t; s < n; s++) { const r = this.cells[s]; r.setPosition(e); e += r.size.outerWidth; this.maxCellHeight = Math.max(r.size.outerHeight, this.maxCellHeight); } this.slideableWidth = e; this.updateSlides(); this._containSlides(); this.slidesWidth = n ? this.getLastSlide().target - this.slides[0].target : 0; }; v._sizeCells = function (t) { t.forEach(function (t) { t.getSize(); }); }; v.updateSlides = function () { this.slides = []; if (!this.cells.length) { return; } let n = new o(this); this.slides.push(n); const t = this.originSide == "left"; const s = t ? "marginRight" : "marginLeft"; const r = this._getCanCellFit(); this.cells.forEach(function (t, e) { if (!n.cells.length) { n.addCell(t); return; } const i = n.outerWidth - n.firstMargin + (t.size.outerWidth - t.size[s]); if (r.call(this, e, i)) { n.addCell(t); } else { n.updateTarget(); n = new o(this); this.slides.push(n); n.addCell(t); } }, this); n.updateTarget(); this.updateSelectedSlide(); }; v._getCanCellFit = function () { const t = this.options.groupCells; if (!t) { return function () { return false; }; } else if (typeof t === "number") { const e = parseInt(t, 10); return function (t) { return t % e !== 0; }; } const i = typeof t === "string" && t.match(/^(\d+)%$/); const n = i ? parseInt(i[1], 10) / 100 : 1; return function (t, e) { return e <= (this.size.innerWidth + 1) * n; }; }; v._init = v.reposition = function () { this.positionCells(); this.positionSliderAtSelected(); }; v.getSize = function () { this.size = i(this.element); this.setCellAlign(); this.cursorPosition = this.size.innerWidth * this.cellAlign; }; const g = { center: { left: 0.5, right: 0.5 }, left: { left: 0, right: 1 }, right: { right: 0, left: 1 } }; v.setCellAlign = function () { const t = g[this.options.cellAlign]; this.cellAlign = t ? t[this.originSide] : this.options.cellAlign; }; v.setGallerySize = function () { if (this.options.setGallerySize) { const t = this.options.adaptiveHeight && this.selectedSlide ? this.selectedSlide.height : this.maxCellHeight; this.viewport.style.height = t + "px"; } }; v._getWrapShiftCells = function () { if (!this.options.wrapAround) { return; } this._unshiftCells(this.beforeShiftCells); this._unshiftCells(this.afterShiftCells); let t = this.cursorPosition; const e = this.cells.length - 1; this.beforeShiftCells = this._getGapCells(t, e, -1); t = this.size.innerWidth - this.cursorPosition; this.afterShiftCells = this._getGapCells(t, 0, 1); }; v._getGapCells = function (t, e, i) { const n = []; while (t > 0) { const s = this.cells[e]; if (!s) { break; }n.push(s); e += i; t -= s.size.outerWidth; } return n; }; v._containSlides = function () { if (!this.options.contain || this.options.wrapAround || !this.cells.length) { return; } const t = this.options.rightToLeft; const e = t ? "marginRight" : "marginLeft"; const i = t ? "marginLeft" : "marginRight"; const n = this.slideableWidth - this.getLastCell().size[i]; const s = n < this.size.innerWidth; const r = this.cursorPosition + this.cells[0].size[e]; const o = n - this.size.innerWidth * (1 - this.cellAlign); this.slides.forEach(function (t) { if (s) { t.target = n * this.cellAlign; } else { t.target = Math.max(t.target, r); t.target = Math.min(t.target, o); } }, this); }; v.dispatchEvent = function (t, e, i) { const n = e ? [e].concat(i) : i; this.emitEvent(t, n); if (l && this.$element) { t += this.options.namespaceJQueryEvents ? ".flickity" : ""; let s = t; if (e) { const r = new l.Event(e); r.type = t; s = r; } this.$element.trigger(s, i); } }; v.select = function (t, e, i) { if (!this.isActive) { return; }t = parseInt(t, 10); this._wrapSelect(t); if (this.options.wrapAround || e) { t = a.modulo(t, this.slides.length); } if (!this.slides[t]) { return; } const n = this.selectedIndex; this.selectedIndex = t; this.updateSelectedSlide(); if (i) { this.positionSliderAtSelected(); } else { this.startAnimation(); } if (this.options.adaptiveHeight) { this.setGallerySize(); } this.dispatchEvent("select", null, [t]); if (t != n) { this.dispatchEvent("change", null, [t]); } this.dispatchEvent("cellSelect"); }; v._wrapSelect = function (t) { const e = this.slides.length; const i = this.options.wrapAround && e > 1; if (!i) { return t; } const n = a.modulo(t, e); const s = Math.abs(n - this.selectedIndex); const r = Math.abs(n + e - this.selectedIndex); const o = Math.abs(n - e - this.selectedIndex); if (!this.isDragSelect && r < s) { t += e; } else if (!this.isDragSelect && o < s) { t -= e; } if (t < 0) { this.x -= this.slideableWidth; } else if (t >= e) { this.x += this.slideableWidth; } }; v.previous = function (t, e) { this.select(this.selectedIndex - 1, t, e); }; v.next = function (t, e) { this.select(this.selectedIndex + 1, t, e); }; v.updateSelectedSlide = function () { const t = this.slides[this.selectedIndex]; if (!t) { return; } this.unselectSelectedSlide(); this.selectedSlide = t; t.select(); this.selectedCells = t.cells; this.selectedElements = t.getCellElements(); this.selectedCell = t.cells[0]; this.selectedElement = this.selectedElements[0]; }; v.unselectSelectedSlide = function () { if (this.selectedSlide) { this.selectedSlide.unselect(); } }; v.selectInitialIndex = function () { const t = this.options.initialIndex; if (this.isInitActivated) { this.select(this.selectedIndex, false, true); return; } if (t && typeof t === "string") { const e = this.queryCell(t); if (e) { this.selectCell(t, false, true); return; } } let i = 0; if (t && this.slides[t]) { i = t; } this.select(i, false, true); }; v.selectCell = function (t, e, i) { const n = this.queryCell(t); if (!n) { return; } const s = this.getCellSlideIndex(n); this.select(s, e, i); }; v.getCellSlideIndex = function (t) { for (let e = 0; e < this.slides.length; e++) { const i = this.slides[e]; const n = i.cells.indexOf(t); if (n != -1) { return e; } } }; v.getCell = function (t) { for (let e = 0; e < this.cells.length; e++) { const i = this.cells[e]; if (i.element == t) { return i; } } }; v.getCells = function (t) { t = a.makeArray(t); const i = []; t.forEach(function (t) { const e = this.getCell(t); if (e) { i.push(e); } }, this); return i; }; v.getCellElements = function () { return this.cells.map(function (t) { return t.element; }); }; v.getParentCell = function (t) { const e = this.getCell(t); if (e) { return e; }t = a.getParent(t, ".flickity-slider > *"); return this.getCell(t); }; v.getAdjacentCellElements = function (t, e) { if (!t) { return this.selectedSlide.getCellElements(); }e = e === undefined ? this.selectedIndex : e; const i = this.slides.length; if (1 + t * 2 >= i) { return this.getCellElements(); } let n = []; for (let s = e - t; s <= e + t; s++) { const r = this.options.wrapAround ? a.modulo(s, i) : s; const o = this.slides[r]; if (o) { n = n.concat(o.getCellElements()); } } return n; }; v.queryCell = function (t) { if (typeof t === "number") { return this.cells[t]; } if (typeof t === "string") { if (t.match(/^[#.]?[\d/]/)) { return; }t = this.element.querySelector(t); } return this.getCell(t); }; v.uiChange = function () { this.emitEvent("uiChange"); }; v.childUIPointerDown = function (t) { if (t.type != "touchstart") { t.preventDefault(); } this.focus(); }; v.onresize = function () { this.watchCSS(); this.resize(); }; a.debounceMethod(p, "onresize", 150); v.resize = function () { if (!this.isActive || this.isAnimating || this.isDragging) { return; } this.getSize(); if (this.options.wrapAround) { this.x = a.modulo(this.x, this.slideableWidth); } this.positionCells(); this._getWrapShiftCells(); this.setGallerySize(); this.emitEvent("resize"); const t = this.selectedElements && this.selectedElements[0]; this.selectCell(t, false, true); }; v.watchCSS = function () { const t = this.options.watchCSS; if (!t) { return; } const e = h(this.element, ":after").content; if (e.indexOf("flickity") != -1) { this.activate(); } else { this.deactivate(); } }; v.onkeydown = function (t) { const e = document.activeElement && document.activeElement != this.element; if (!this.options.accessibility || e) { return; } const i = p.keyboardHandlers[t.keyCode]; if (i) { i.call(this); } }; p.keyboardHandlers = { 37: function () { const t = this.options.rightToLeft ? "next" : "previous"; this.uiChange(); this[t](); }, 39: function () { const t = this.options.rightToLeft ? "previous" : "next"; this.uiChange(); this[t](); } }; v.focus = function () { const t = n.pageYOffset; this.element.focus({ preventScroll: true }); if (n.pageYOffset != t) { n.scrollTo(n.pageXOffset, t); } }; v.deactivate = function () { if (!this.isActive) { return; } this.element.classList.remove("flickity-enabled"); this.element.classList.remove("flickity-rtl"); this.unselectSelectedSlide(); this.cells.forEach(function (t) { t.destroy(); }); this.element.removeChild(this.viewport); u(this.slider.children, this.element); if (this.options.accessibility) { this.element.removeAttribute("tabIndex"); this.element.removeEventListener("keydown", this); } this.isActive = false; this.emitEvent("deactivate"); }; v.destroy = function () { this.deactivate(); n.removeEventListener("resize", this); this.allOff(); this.emitEvent("destroy"); if (l && this.$element) { l.removeData(this.element, "flickity"); } delete this.element.flickityGUID; delete f[this.guid]; }; a.extend(v, r); p.data = function (t) { t = a.getQueryElement(t); const e = t && t.flickityGUID; return e && f[e]; }; a.htmlInit(p, "flickity"); if (l && l.bridget) { l.bridget("flickity", p); }p.setJQuery = function (t) { l = t; }; p.Cell = s; p.Slide = o; return p; });
/*!
 * Unipointer v2.4.0
 * base class for doing one thing with pointer event
 * MIT license
 */
(function (e, i) { if (typeof define === "function" && define.amd) { define("unipointer/unipointer", ["ev-emitter/ev-emitter"], function (t) { return i(e, t); }); } else if (typeof module === "object" && module.exports) { module.exports = i(e, require("ev-emitter")); } else { e.Unipointer = i(e, e.EvEmitter); } })(window, function t (s, e) { function i () {} function n () {} const r = n.prototype = Object.create(e.prototype); r.bindStartEvent = function (t) { this._bindStartEvent(t, true); }; r.unbindStartEvent = function (t) { this._bindStartEvent(t, false); }; r._bindStartEvent = function (t, e) { e = e === undefined ? true : e; const i = e ? "addEventListener" : "removeEventListener"; let n = "mousedown"; if ("ontouchstart" in s) { n = "touchstart"; } else if (s.PointerEvent) { n = "pointerdown"; }t[i](n, this); }; r.handleEvent = function (t) { const e = "on" + t.type; if (this[e]) { this[e](t); } }; r.getTouch = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; if (i.identifier == this.pointerIdentifier) { return i; } } }; r.onmousedown = function (t) { const e = t.button; if (e && (e !== 0 && e !== 1)) { return; } this._pointerDown(t, t); }; r.ontouchstart = function (t) { this._pointerDown(t, t.changedTouches[0]); }; r.onpointerdown = function (t) { this._pointerDown(t, t); }; r._pointerDown = function (t, e) { if (t.button || this.isPointerDown) { return; } this.isPointerDown = true; this.pointerIdentifier = e.pointerId !== undefined ? e.pointerId : e.identifier; this.pointerDown(t, e); }; r.pointerDown = function (t, e) { this._bindPostStartEvents(t); this.emitEvent("pointerDown", [t, e]); }; const o = { mousedown: ["mousemove", "mouseup"], touchstart: ["touchmove", "touchend", "touchcancel"], pointerdown: ["pointermove", "pointerup", "pointercancel"] }; r._bindPostStartEvents = function (t) { if (!t) { return; } const e = o[t.type]; e.forEach(function (t) { s.addEventListener(t, this); }, this); this._boundPointerEvents = e; }; r._unbindPostStartEvents = function () { if (!this._boundPointerEvents) { return; } this._boundPointerEvents.forEach(function (t) { s.removeEventListener(t, this); }, this); delete this._boundPointerEvents; }; r.onmousemove = function (t) { this._pointerMove(t, t); }; r.onpointermove = function (t) { if (t.pointerId == this.pointerIdentifier) { this._pointerMove(t, t); } }; r.ontouchmove = function (t) { const e = this.getTouch(t.changedTouches); if (e) { this._pointerMove(t, e); } }; r._pointerMove = function (t, e) { this.pointerMove(t, e); }; r.pointerMove = function (t, e) { this.emitEvent("pointerMove", [t, e]); }; r.onmouseup = function (t) { this._pointerUp(t, t); }; r.onpointerup = function (t) { if (t.pointerId == this.pointerIdentifier) { this._pointerUp(t, t); } }; r.ontouchend = function (t) { const e = this.getTouch(t.changedTouches); if (e) { this._pointerUp(t, e); } }; r._pointerUp = function (t, e) { this._pointerDone(); this.pointerUp(t, e); }; r.pointerUp = function (t, e) { this.emitEvent("pointerUp", [t, e]); }; r._pointerDone = function () { this._pointerReset(); this._unbindPostStartEvents(); this.pointerDone(); }; r._pointerReset = function () { this.isPointerDown = false; delete this.pointerIdentifier; }; r.pointerDone = i; r.onpointercancel = function (t) { if (t.pointerId == this.pointerIdentifier) { this._pointerCancel(t, t); } }; r.ontouchcancel = function (t) { const e = this.getTouch(t.changedTouches); if (e) { this._pointerCancel(t, e); } }; r._pointerCancel = function (t, e) { this._pointerDone(); this.pointerCancel(t, e); }; r.pointerCancel = function (t, e) { this.emitEvent("pointerCancel", [t, e]); }; n.getPointerPoint = function (t) { return { x: t.pageX, y: t.pageY }; }; return n; });
/*!
 * Unidragger v2.4.0
 * Draggable base class
 * MIT license
 */
(function (e, i) { if (typeof define === "function" && define.amd) { define("unidragger/unidragger", ["unipointer/unipointer"], function (t) { return i(e, t); }); } else if (typeof module === "object" && module.exports) { module.exports = i(e, require("unipointer")); } else { e.Unidragger = i(e, e.Unipointer); } })(window, function t (r, e) { function i () {} const n = i.prototype = Object.create(e.prototype); n.bindHandles = function () { this._bindHandles(true); }; n.unbindHandles = function () { this._bindHandles(false); }; n._bindHandles = function (t) { t = t === undefined ? true : t; const e = t ? "addEventListener" : "removeEventListener"; const i = t ? this._touchActionValue : ""; for (let n = 0; n < this.handles.length; n++) { const s = this.handles[n]; this._bindStartEvent(s, t); s[e]("click", this); if (r.PointerEvent) { s.style.touchAction = i; } } }; n._touchActionValue = "none"; n.pointerDown = function (t, e) { const i = this.okayPointerDown(t); if (!i) { return; } this.pointerDownPointer = { pageX: e.pageX, pageY: e.pageY }; t.preventDefault(); this.pointerDownBlur(); this._bindPostStartEvents(t); this.emitEvent("pointerDown", [t, e]); }; const s = { TEXTAREA: true, INPUT: true, SELECT: true, OPTION: true }; const o = { radio: true, checkbox: true, button: true, submit: true, image: true, file: true }; n.okayPointerDown = function (t) { const e = s[t.target.nodeName]; const i = o[t.target.type]; const n = !e || i; if (!n) { this._pointerReset(); } return n; }; n.pointerDownBlur = function () { const t = document.activeElement; const e = t && t.blur && t != document.body; if (e) { t.blur(); } }; n.pointerMove = function (t, e) { const i = this._dragPointerMove(t, e); this.emitEvent("pointerMove", [t, e, i]); this._dragMove(t, e, i); }; n._dragPointerMove = function (t, e) { const i = { x: e.pageX - this.pointerDownPointer.pageX, y: e.pageY - this.pointerDownPointer.pageY }; if (!this.isDragging && this.hasDragStarted(i)) { this._dragStart(t, e); } return i; }; n.hasDragStarted = function (t) { return Math.abs(t.x) > 3 || Math.abs(t.y) > 3; }; n.pointerUp = function (t, e) { this.emitEvent("pointerUp", [t, e]); this._dragPointerUp(t, e); }; n._dragPointerUp = function (t, e) { if (this.isDragging) { this._dragEnd(t, e); } else { this._staticClick(t, e); } }; n._dragStart = function (t, e) { this.isDragging = true; this.isPreventingClicks = true; this.dragStart(t, e); }; n.dragStart = function (t, e) { this.emitEvent("dragStart", [t, e]); }; n._dragMove = function (t, e, i) { if (!this.isDragging) { return; } this.dragMove(t, e, i); }; n.dragMove = function (t, e, i) { t.preventDefault(); this.emitEvent("dragMove", [t, e, i]); }; n._dragEnd = function (t, e) { this.isDragging = false; setTimeout(function () { delete this.isPreventingClicks; }.bind(this)); this.dragEnd(t, e); }; n.dragEnd = function (t, e) { this.emitEvent("dragEnd", [t, e]); }; n.onclick = function (t) { if (this.isPreventingClicks) { t.preventDefault(); } }; n._staticClick = function (t, e) { if (this.isIgnoringMouseUp && t.type == "mouseup") { return; } this.staticClick(t, e); if (t.type != "mouseup") { this.isIgnoringMouseUp = true; setTimeout(function () { delete this.isIgnoringMouseUp; }.bind(this), 400); } }; n.staticClick = function (t, e) { this.emitEvent("staticClick", [t, e]); }; i.getPointerPoint = e.getPointerPoint; return i; }); (function (n, s) { if (typeof define === "function" && define.amd) { define("flickity/js/drag", ["./flickity", "unidragger/unidragger", "fizzy-ui-utils/utils"], function (t, e, i) { return s(n, t, e, i); }); } else if (typeof module === "object" && module.exports) { module.exports = s(n, require("./flickity"), require("unidragger"), require("fizzy-ui-utils")); } else { n.Flickity = s(n, n.Flickity, n.Unidragger, n.fizzyUIUtils); } })(window, function t (n, e, i, a) { a.extend(e.defaults, { draggable: ">1", dragThreshold: 3 }); e.createMethods.push("_createDrag"); const s = e.prototype; a.extend(s, i.prototype); s._touchActionValue = "pan-y"; s._createDrag = function () { this.on("activate", this.onActivateDrag); this.on("uiChange", this._uiChangeDrag); this.on("deactivate", this.onDeactivateDrag); this.on("cellChange", this.updateDraggable); }; s.onActivateDrag = function () { this.handles = [this.viewport]; this.bindHandles(); this.updateDraggable(); }; s.onDeactivateDrag = function () { this.unbindHandles(); this.element.classList.remove("is-draggable"); }; s.updateDraggable = function () { if (this.options.draggable == ">1") { this.isDraggable = this.slides.length > 1; } else { this.isDraggable = this.options.draggable; } if (this.isDraggable) { this.element.classList.add("is-draggable"); } else { this.element.classList.remove("is-draggable"); } }; s.bindDrag = function () { this.options.draggable = true; this.updateDraggable(); }; s.unbindDrag = function () { this.options.draggable = false; this.updateDraggable(); }; s._uiChangeDrag = function () { delete this.isFreeScrolling; }; s.pointerDown = function (t, e) { if (!this.isDraggable) { this._pointerDownDefault(t, e); return; } const i = this.okayPointerDown(t); if (!i) { return; } this._pointerDownPreventDefault(t); this.pointerDownFocus(t); if (document.activeElement != this.element) { this.pointerDownBlur(); } this.dragX = this.x; this.viewport.classList.add("is-pointer-down"); this.pointerDownScroll = o(); n.addEventListener("scroll", this); this._pointerDownDefault(t, e); }; s._pointerDownDefault = function (t, e) { this.pointerDownPointer = { pageX: e.pageX, pageY: e.pageY }; this._bindPostStartEvents(t); this.dispatchEvent("pointerDown", t, [e]); }; const r = { INPUT: true, TEXTAREA: true, SELECT: true }; s.pointerDownFocus = function (t) { const e = r[t.target.nodeName]; if (!e) { this.focus(); } }; s._pointerDownPreventDefault = function (t) { const e = t.type == "touchstart"; const i = t.pointerType == "touch"; const n = r[t.target.nodeName]; if (!e && !i && !n) { t.preventDefault(); } }; s.hasDragStarted = function (t) { return Math.abs(t.x) > this.options.dragThreshold; }; s.pointerUp = function (t, e) { delete this.isTouchScrolling; this.viewport.classList.remove("is-pointer-down"); this.dispatchEvent("pointerUp", t, [e]); this._dragPointerUp(t, e); }; s.pointerDone = function () { n.removeEventListener("scroll", this); delete this.pointerDownScroll; }; s.dragStart = function (t, e) { if (!this.isDraggable) { return; } this.dragStartPosition = this.x; this.startAnimation(); n.removeEventListener("scroll", this); this.dispatchEvent("dragStart", t, [e]); }; s.pointerMove = function (t, e) { const i = this._dragPointerMove(t, e); this.dispatchEvent("pointerMove", t, [e, i]); this._dragMove(t, e, i); }; s.dragMove = function (t, e, i) { if (!this.isDraggable) { return; }t.preventDefault(); this.previousDragX = this.dragX; const n = this.options.rightToLeft ? -1 : 1; if (this.options.wrapAround) { i.x %= this.slideableWidth; } let s = this.dragStartPosition + i.x * n; if (!this.options.wrapAround && this.slides.length) { const r = Math.max(-this.slides[0].target, this.dragStartPosition); s = s > r ? (s + r) * 0.5 : s; const o = Math.min(-this.getLastSlide().target, this.dragStartPosition); s = s < o ? (s + o) * 0.5 : s; } this.dragX = s; this.dragMoveTime = new Date(); this.dispatchEvent("dragMove", t, [e, i]); }; s.dragEnd = function (t, e) { if (!this.isDraggable) { return; } if (this.options.freeScroll) { this.isFreeScrolling = true; } let i = this.dragEndRestingSelect(); if (this.options.freeScroll && !this.options.wrapAround) { const n = this.getRestingPosition(); this.isFreeScrolling = -n > this.slides[0].target && -n < this.getLastSlide().target; } else if (!this.options.freeScroll && i == this.selectedIndex) { i += this.dragEndBoostSelect(); } delete this.previousDragX; this.isDragSelect = this.options.wrapAround; this.select(i); delete this.isDragSelect; this.dispatchEvent("dragEnd", t, [e]); }; s.dragEndRestingSelect = function () { const t = this.getRestingPosition(); const e = Math.abs(this.getSlideDistance(-t, this.selectedIndex)); const i = this._getClosestResting(t, e, 1); const n = this._getClosestResting(t, e, -1); const s = i.distance < n.distance ? i.index : n.index; return s; }; s._getClosestResting = function (t, e, i) { let n = this.selectedIndex; let s = Infinity; const r = this.options.contain && !this.options.wrapAround ? function (t, e) { return t <= e; } : function (t, e) { return t < e; }; while (r(e, s)) { n += i; s = e; e = this.getSlideDistance(-t, n); if (e === null) { break; }e = Math.abs(e); } return { distance: s, index: n - i }; }; s.getSlideDistance = function (t, e) { const i = this.slides.length; const n = this.options.wrapAround && i > 1; const s = n ? a.modulo(e, i) : e; const r = this.slides[s]; if (!r) { return null; } const o = n ? this.slideableWidth * Math.floor(e / i) : 0; return t - (r.target + o); }; s.dragEndBoostSelect = function () { if (this.previousDragX === undefined || !this.dragMoveTime || new Date() - this.dragMoveTime > 100) { return 0; } const t = this.getSlideDistance(-this.dragX, this.selectedIndex); const e = this.previousDragX - this.dragX; if (t > 0 && e > 0) { return 1; } else if (t < 0 && e < 0) { return -1; } return 0; }; s.staticClick = function (t, e) { const i = this.getParentCell(t.target); const n = i && i.element; const s = i && this.cells.indexOf(i); this.dispatchEvent("staticClick", t, [e, n, s]); }; s.onscroll = function () { const t = o(); const e = this.pointerDownScroll.x - t.x; const i = this.pointerDownScroll.y - t.y; if (Math.abs(e) > 3 || Math.abs(i) > 3) { this._pointerDone(); } }; function o () { return { x: n.pageXOffset, y: n.pageYOffset }; } return e; }); (function (n, s) { if (typeof define === "function" && define.amd) { define("flickity/js/prev-next-button", ["./flickity", "unipointer/unipointer", "fizzy-ui-utils/utils"], function (t, e, i) { return s(n, t, e, i); }); } else if (typeof module === "object" && module.exports) { module.exports = s(n, require("./flickity"), require("unipointer"), require("fizzy-ui-utils")); } else { s(n, n.Flickity, n.Unipointer, n.fizzyUIUtils); } })(window, function t (e, i, n, s) { "use strict"; const r = "http://www.w3.org/2000/svg"; function o (t, e) { this.direction = t; this.parent = e; this._create(); }o.prototype = Object.create(n.prototype); o.prototype._create = function () { this.isEnabled = true; this.isPrevious = this.direction == -1; const t = this.parent.options.rightToLeft ? 1 : -1; this.isLeft = this.direction == t; const e = this.element = document.createElement("button"); e.className = "flickity-button flickity-prev-next-button"; e.className += this.isPrevious ? " previous" : " next"; e.setAttribute("type", "button"); this.disable(); e.setAttribute("aria-label", this.isPrevious ? "Previous" : "Next"); const i = this.createSVG(); e.appendChild(i); this.parent.on("select", this.update.bind(this)); this.on("pointerDown", this.parent.childUIPointerDown.bind(this.parent)); }; o.prototype.activate = function () { this.bindStartEvent(this.element); this.element.addEventListener("click", this); this.parent.element.appendChild(this.element); }; o.prototype.deactivate = function () { this.parent.element.removeChild(this.element); this.unbindStartEvent(this.element); this.element.removeEventListener("click", this); }; o.prototype.createSVG = function () { const t = document.createElementNS(r, "svg"); t.setAttribute("class", "flickity-button-icon"); t.setAttribute("viewBox", "0 0 100 100"); const e = document.createElementNS(r, "path"); const i = a(this.parent.options.arrowShape); e.setAttribute("d", i); e.setAttribute("class", "arrow"); if (!this.isLeft) { e.setAttribute("transform", "translate(100, 100) rotate(180) "); }t.appendChild(e); return t; }; function a (t) { if (typeof t === "string") { return t; } return "M " + t.x0 + ",50" + " L " + t.x1 + "," + (t.y1 + 50) + " L " + t.x2 + "," + (t.y2 + 50) + " L " + t.x3 + ",50 " + " L " + t.x2 + "," + (50 - t.y2) + " L " + t.x1 + "," + (50 - t.y1) + " Z"; }o.prototype.handleEvent = s.handleEvent; o.prototype.onclick = function () { if (!this.isEnabled) { return; } this.parent.uiChange(); const t = this.isPrevious ? "previous" : "next"; this.parent[t](); }; o.prototype.enable = function () { if (this.isEnabled) { return; } this.element.disabled = false; this.isEnabled = true; }; o.prototype.disable = function () { if (!this.isEnabled) { return; } this.element.disabled = true; this.isEnabled = false; }; o.prototype.update = function () { const t = this.parent.slides; if (this.parent.options.wrapAround && t.length > 1) { this.enable(); return; } const e = t.length ? t.length - 1 : 0; const i = this.isPrevious ? 0 : e; const n = this.parent.selectedIndex == i ? "disable" : "enable"; this[n](); }; o.prototype.destroy = function () { this.deactivate(); this.allOff(); }; s.extend(i.defaults, { prevNextButtons: true, arrowShape: { x0: 10, x1: 60, y1: 50, x2: 70, y2: 40, x3: 30 } }); i.createMethods.push("_createPrevNextButtons"); const l = i.prototype; l._createPrevNextButtons = function () { if (!this.options.prevNextButtons) { return; } this.prevButton = new o(-1, this); this.nextButton = new o(1, this); this.on("activate", this.activatePrevNextButtons); }; l.activatePrevNextButtons = function () { this.prevButton.activate(); this.nextButton.activate(); this.on("deactivate", this.deactivatePrevNextButtons); }; l.deactivatePrevNextButtons = function () { this.prevButton.deactivate(); this.nextButton.deactivate(); this.off("deactivate", this.deactivatePrevNextButtons); }; i.PrevNextButton = o; return i; }); (function (n, s) { if (typeof define === "function" && define.amd) { define("flickity/js/page-dots", ["./flickity", "unipointer/unipointer", "fizzy-ui-utils/utils"], function (t, e, i) { return s(n, t, e, i); }); } else if (typeof module === "object" && module.exports) { module.exports = s(n, require("./flickity"), require("unipointer"), require("fizzy-ui-utils")); } else { s(n, n.Flickity, n.Unipointer, n.fizzyUIUtils); } })(window, function t (e, i, n, s) { function r (t) { this.parent = t; this._create(); }r.prototype = Object.create(n.prototype); r.prototype._create = function () { this.holder = document.createElement("ol"); this.holder.className = "flickity-page-dots"; this.dots = []; this.handleClick = this.onClick.bind(this); this.on("pointerDown", this.parent.childUIPointerDown.bind(this.parent)); }; r.prototype.activate = function () { this.setDots(); this.holder.addEventListener("click", this.handleClick); this.bindStartEvent(this.holder); this.parent.element.appendChild(this.holder); }; r.prototype.deactivate = function () { this.holder.removeEventListener("click", this.handleClick); this.unbindStartEvent(this.holder); this.parent.element.removeChild(this.holder); }; r.prototype.setDots = function () { const t = this.parent.slides.length - this.dots.length; if (t > 0) { this.addDots(t); } else if (t < 0) { this.removeDots(-t); } }; r.prototype.addDots = function (t) { const e = document.createDocumentFragment(); const i = []; const n = this.dots.length; const s = n + t; for (let r = n; r < s; r++) { const o = document.createElement("li"); o.className = "dot"; o.setAttribute("aria-label", "Page dot " + (r + 1)); e.appendChild(o); i.push(o); } this.holder.appendChild(e); this.dots = this.dots.concat(i); }; r.prototype.removeDots = function (t) { const e = this.dots.splice(this.dots.length - t, t); e.forEach(function (t) { this.holder.removeChild(t); }, this); }; r.prototype.updateSelected = function () { if (this.selectedDot) { this.selectedDot.className = "dot"; this.selectedDot.removeAttribute("aria-current"); } if (!this.dots.length) { return; } this.selectedDot = this.dots[this.parent.selectedIndex]; this.selectedDot.className = "dot is-selected"; this.selectedDot.setAttribute("aria-current", "step"); }; r.prototype.onTap = r.prototype.onClick = function (t) { const e = t.target; if (e.nodeName != "LI") { return; } this.parent.uiChange(); const i = this.dots.indexOf(e); this.parent.select(i); }; r.prototype.destroy = function () { this.deactivate(); this.allOff(); }; i.PageDots = r; s.extend(i.defaults, { pageDots: true }); i.createMethods.push("_createPageDots"); const o = i.prototype; o._createPageDots = function () { if (!this.options.pageDots) { return; } this.pageDots = new r(this); this.on("activate", this.activatePageDots); this.on("select", this.updateSelectedPageDots); this.on("cellChange", this.updatePageDots); this.on("resize", this.updatePageDots); this.on("deactivate", this.deactivatePageDots); }; o.activatePageDots = function () { this.pageDots.activate(); }; o.updateSelectedPageDots = function () { this.pageDots.updateSelected(); }; o.updatePageDots = function () { this.pageDots.setDots(); }; o.deactivatePageDots = function () { this.pageDots.deactivate(); }; i.PageDots = r; return i; }); (function (t, n) { if (typeof define === "function" && define.amd) { define("flickity/js/player", ["ev-emitter/ev-emitter", "fizzy-ui-utils/utils", "./flickity"], function (t, e, i) { return n(t, e, i); }); } else if (typeof module === "object" && module.exports) { module.exports = n(require("ev-emitter"), require("fizzy-ui-utils"), require("./flickity")); } else { n(t.EvEmitter, t.fizzyUIUtils, t.Flickity); } })(window, function t (e, i, n) { function s (t) { this.parent = t; this.state = "stopped"; this.onVisibilityChange = this.visibilityChange.bind(this); this.onVisibilityPlay = this.visibilityPlay.bind(this); }s.prototype = Object.create(e.prototype); s.prototype.play = function () { if (this.state == "playing") { return; } const t = document.hidden; if (t) { document.addEventListener("visibilitychange", this.onVisibilityPlay); return; } this.state = "playing"; document.addEventListener("visibilitychange", this.onVisibilityChange); this.tick(); }; s.prototype.tick = function () { if (this.state != "playing") { return; } let t = this.parent.options.autoPlay; t = typeof t === "number" ? t : 3e3; const e = this; this.clear(); this.timeout = setTimeout(function () { e.parent.next(true); e.tick(); }, t); }; s.prototype.stop = function () { this.state = "stopped"; this.clear(); document.removeEventListener("visibilitychange", this.onVisibilityChange); }; s.prototype.clear = function () { clearTimeout(this.timeout); }; s.prototype.pause = function () { if (this.state == "playing") { this.state = "paused"; this.clear(); } }; s.prototype.unpause = function () { if (this.state == "paused") { this.play(); } }; s.prototype.visibilityChange = function () { const t = document.hidden; this[t ? "pause" : "unpause"](); }; s.prototype.visibilityPlay = function () { this.play(); document.removeEventListener("visibilitychange", this.onVisibilityPlay); }; i.extend(n.defaults, { pauseAutoPlayOnHover: true }); n.createMethods.push("_createPlayer"); const r = n.prototype; r._createPlayer = function () { this.player = new s(this); this.on("activate", this.activatePlayer); this.on("uiChange", this.stopPlayer); this.on("pointerDown", this.stopPlayer); this.on("deactivate", this.deactivatePlayer); }; r.activatePlayer = function () { if (!this.options.autoPlay) { return; } this.player.play(); this.element.addEventListener("mouseenter", this); }; r.playPlayer = function () { this.player.play(); }; r.stopPlayer = function () { this.player.stop(); }; r.pausePlayer = function () { this.player.pause(); }; r.unpausePlayer = function () { this.player.unpause(); }; r.deactivatePlayer = function () { this.player.stop(); this.element.removeEventListener("mouseenter", this); }; r.onmouseenter = function () { if (!this.options.pauseAutoPlayOnHover) { return; } this.player.pause(); this.element.addEventListener("mouseleave", this); }; r.onmouseleave = function () { this.player.unpause(); this.element.removeEventListener("mouseleave", this); }; n.Player = s; return n; }); (function (i, n) { if (typeof define === "function" && define.amd) { define("flickity/js/add-remove-cell", ["./flickity", "fizzy-ui-utils/utils"], function (t, e) { return n(i, t, e); }); } else if (typeof module === "object" && module.exports) { module.exports = n(i, require("./flickity"), require("fizzy-ui-utils")); } else { n(i, i.Flickity, i.fizzyUIUtils); } })(window, function t (e, i, n) { function l (t) { const e = document.createDocumentFragment(); t.forEach(function (t) { e.appendChild(t.element); }); return e; } const s = i.prototype; s.insert = function (t, e) { const i = this._makeCells(t); if (!i || !i.length) { return; } const n = this.cells.length; e = e === undefined ? n : e; const s = l(i); const r = e == n; if (r) { this.slider.appendChild(s); } else { const o = this.cells[e].element; this.slider.insertBefore(s, o); } if (e === 0) { this.cells = i.concat(this.cells); } else if (r) { this.cells = this.cells.concat(i); } else { const a = this.cells.splice(e, n - e); this.cells = this.cells.concat(i).concat(a); } this._sizeCells(i); this.cellChange(e, true); }; s.append = function (t) { this.insert(t, this.cells.length); }; s.prepend = function (t) { this.insert(t, 0); }; s.remove = function (t) { const e = this.getCells(t); if (!e || !e.length) { return; } let i = this.cells.length - 1; e.forEach(function (t) { t.remove(); const e = this.cells.indexOf(t); i = Math.min(e, i); n.removeFrom(this.cells, t); }, this); this.cellChange(i, true); }; s.cellSizeChange = function (t) { const e = this.getCell(t); if (!e) { return; }e.getSize(); const i = this.cells.indexOf(e); this.cellChange(i); }; s.cellChange = function (t, e) { const i = this.selectedElement; this._positionCells(t); this._getWrapShiftCells(); this.setGallerySize(); const n = this.getCell(i); if (n) { this.selectedIndex = this.getCellSlideIndex(n); } this.selectedIndex = Math.min(this.slides.length - 1, this.selectedIndex); this.emitEvent("cellChange", [t]); this.select(this.selectedIndex); if (e) { this.positionSliderAtSelected(); } }; return i; }); (function (i, n) { if (typeof define === "function" && define.amd) { define("flickity/js/lazyload", ["./flickity", "fizzy-ui-utils/utils"], function (t, e) { return n(i, t, e); }); } else if (typeof module === "object" && module.exports) { module.exports = n(i, require("./flickity"), require("fizzy-ui-utils")); } else { n(i, i.Flickity, i.fizzyUIUtils); } })(window, function t (e, i, o) { "use strict"; i.createMethods.push("_createLazyload"); const n = i.prototype; n._createLazyload = function () { this.on("select", this.lazyLoad); }; n.lazyLoad = function () { const t = this.options.lazyLoad; if (!t) { return; } const e = typeof t === "number" ? t : 0; const i = this.getAdjacentCellElements(e); let n = []; i.forEach(function (t) { const e = s(t); n = n.concat(e); }); n.forEach(function (t) { new r(t, this); }, this); }; function s (t) { if (t.nodeName == "IMG") { const e = t.getAttribute("data-flickity-lazyload"); const i = t.getAttribute("data-flickity-lazyload-src"); const n = t.getAttribute("data-flickity-lazyload-srcset"); if (e || i || n) { return [t]; } } const s = "img[data-flickity-lazyload], " + "img[data-flickity-lazyload-src], img[data-flickity-lazyload-srcset]"; const r = t.querySelectorAll(s); return o.makeArray(r); } function r (t, e) { this.img = t; this.flickity = e; this.load(); }r.prototype.handleEvent = o.handleEvent; r.prototype.load = function () { this.img.addEventListener("load", this); this.img.addEventListener("error", this); const t = this.img.getAttribute("data-flickity-lazyload") || this.img.getAttribute("data-flickity-lazyload-src"); const e = this.img.getAttribute("data-flickity-lazyload-srcset"); this.img.src = t; if (e) { this.img.setAttribute("srcset", e); } this.img.removeAttribute("data-flickity-lazyload"); this.img.removeAttribute("data-flickity-lazyload-src"); this.img.removeAttribute("data-flickity-lazyload-srcset"); }; r.prototype.onload = function (t) { this.complete(t, "flickity-lazyloaded"); }; r.prototype.onerror = function (t) { this.complete(t, "flickity-lazyerror"); }; r.prototype.complete = function (t, e) { this.img.removeEventListener("load", this); this.img.removeEventListener("error", this); const i = this.flickity.getParentCell(this.img); const n = i && i.element; this.flickity.cellSizeChange(n); this.img.classList.add(e); this.flickity.dispatchEvent("lazyLoad", t, n); }; i.LazyLoader = r; return i; });
/*!
 * Flickity v2.3.0
 * Touch, responsive, flickable carousels
 *
 * Licensed GPLv3 for open source use
 * or Flickity Commercial License for commercial use
 *
 * https://flickity.metafizzy.co
 * Copyright 2015-2021 Metafizzy
 */
(function (t, e) { if (typeof define === "function" && define.amd) { define("flickity/js/index", ["./flickity", "./drag", "./prev-next-button", "./page-dots", "./player", "./add-remove-cell", "./lazyload"], e); } else if (typeof module === "object" && module.exports) { module.exports = e(require("./flickity"), require("./drag"), require("./prev-next-button"), require("./page-dots"), require("./player"), require("./add-remove-cell"), require("./lazyload")); } })(window, function t (e) { return e; });
/*!
 * Flickity asNavFor v2.0.2
 * enable asNavFor for Flickity
 */
(function (t, e) { if (typeof define === "function" && define.amd) { define("flickity-as-nav-for/as-nav-for", ["flickity/js/index", "fizzy-ui-utils/utils"], e); } else if (typeof module === "object" && module.exports) { module.exports = e(require("flickity"), require("fizzy-ui-utils")); } else { t.Flickity = e(t.Flickity, t.fizzyUIUtils); } })(window, function t (n, s) { n.createMethods.push("_createAsNavFor"); const e = n.prototype; e._createAsNavFor = function () { this.on("activate", this.activateAsNavFor); this.on("deactivate", this.deactivateAsNavFor); this.on("destroy", this.destroyAsNavFor); const e = this.options.asNavFor; if (!e) { return; } const i = this; setTimeout(function t () { i.setNavCompanion(e); }); }; e.setNavCompanion = function (t) { t = s.getQueryElement(t); const e = n.data(t); if (!e || e == this) { return; } this.navCompanion = e; const i = this; this.onNavCompanionSelect = function () { i.navCompanionSelect(); }; e.on("select", this.onNavCompanionSelect); this.on("staticClick", this.onNavStaticClick); this.navCompanionSelect(true); }; e.navCompanionSelect = function (t) { const e = this.navCompanion && this.navCompanion.selectedCells; if (!e) { return; } const i = e[0]; const n = this.navCompanion.cells.indexOf(i); const s = n + e.length - 1; const r = Math.floor(a(n, s, this.navCompanion.cellAlign)); this.selectCell(r, false, t); this.removeNavSelectedElements(); if (r >= this.cells.length) { return; } const o = this.cells.slice(n, s + 1); this.navSelectedElements = o.map(function (t) { return t.element; }); this.changeNavSelectedClass("add"); }; function a (t, e, i) { return (e - t) * i + t; }e.changeNavSelectedClass = function (e) { this.navSelectedElements.forEach(function (t) { t.classList[e]("is-nav-selected"); }); }; e.activateAsNavFor = function () { this.navCompanionSelect(true); }; e.removeNavSelectedElements = function () { if (!this.navSelectedElements) { return; } this.changeNavSelectedClass("remove"); delete this.navSelectedElements; }; e.onNavStaticClick = function (t, e, i, n) { if (typeof n === "number") { this.navCompanion.selectCell(n); } }; e.deactivateAsNavFor = function () { this.removeNavSelectedElements(); }; e.destroyAsNavFor = function () { if (!this.navCompanion) { return; } this.navCompanion.off("select", this.onNavCompanionSelect); this.off("staticClick", this.onNavStaticClick); delete this.navCompanion; }; return n; });
/*!
 * imagesLoaded v4.1.4
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */
(function (e, i) { "use strict"; if (typeof define === "function" && define.amd) { define("imagesloaded/imagesloaded", ["ev-emitter/ev-emitter"], function (t) { return i(e, t); }); } else if (typeof module === "object" && module.exports) { module.exports = i(e, require("ev-emitter")); } else { e.imagesLoaded = i(e, e.EvEmitter); } })(typeof window !== "undefined" ? window : this, function t (e, i) { let s = e.jQuery; const r = e.console; function o (t, e) { for (const i in e) { t[i] = e[i]; } return t; } const n = Array.prototype.slice; function a (t) { if (Array.isArray(t)) { return t; } const e = typeof t === "object" && typeof t.length === "number"; if (e) { return n.call(t); } return [t]; } function l (t, e, i) { if (!(this instanceof l)) { return new l(t, e, i); } let n = t; if (typeof t === "string") { n = document.querySelectorAll(t); } if (!n) { r.error("Bad element for imagesLoaded " + (n || t)); return; } this.elements = a(n); this.options = o({}, this.options); if (typeof e === "function") { i = e; } else { o(this.options, e); } if (i) { this.on("always", i); } this.getImages(); if (s) { this.jqDeferred = new s.Deferred(); }setTimeout(this.check.bind(this)); }l.prototype = Object.create(i.prototype); l.prototype.options = {}; l.prototype.getImages = function () { this.images = []; this.elements.forEach(this.addElementImages, this); }; l.prototype.addElementImages = function (t) { if (t.nodeName == "IMG") { this.addImage(t); } if (this.options.background === true) { this.addElementBackgroundImages(t); } const e = t.nodeType; if (!e || !h[e]) { return; } const i = t.querySelectorAll("img"); for (var n = 0; n < i.length; n++) { const s = i[n]; this.addImage(s); } if (typeof this.options.background === "string") { const r = t.querySelectorAll(this.options.background); for (n = 0; n < r.length; n++) { const o = r[n]; this.addElementBackgroundImages(o); } } }; var h = { 1: true, 9: true, 11: true }; l.prototype.addElementBackgroundImages = function (t) { const e = getComputedStyle(t); if (!e) { return; } const i = /url\((['"])?(.*?)\1\)/gi; let n = i.exec(e.backgroundImage); while (n !== null) { const s = n && n[2]; if (s) { this.addBackground(s, t); }n = i.exec(e.backgroundImage); } }; l.prototype.addImage = function (t) { const e = new c(t); this.images.push(e); }; l.prototype.addBackground = function (t, e) { const i = new u(t, e); this.images.push(i); }; l.prototype.check = function () { const n = this; this.progressedCount = 0; this.hasAnyBroken = false; if (!this.images.length) { this.complete(); return; } function e (t, e, i) { setTimeout(function () { n.progress(t, e, i); }); } this.images.forEach(function (t) { t.once("progress", e); t.check(); }); }; l.prototype.progress = function (t, e, i) { this.progressedCount++; this.hasAnyBroken = this.hasAnyBroken || !t.isLoaded; this.emitEvent("progress", [this, t, e]); if (this.jqDeferred && this.jqDeferred.notify) { this.jqDeferred.notify(this, t); } if (this.progressedCount == this.images.length) { this.complete(); } if (this.options.debug && r) { r.log("progress: " + i, t, e); } }; l.prototype.complete = function () { const t = this.hasAnyBroken ? "fail" : "done"; this.isComplete = true; this.emitEvent(t, [this]); this.emitEvent("always", [this]); if (this.jqDeferred) { const e = this.hasAnyBroken ? "reject" : "resolve"; this.jqDeferred[e](this); } }; function c (t) { this.img = t; }c.prototype = Object.create(i.prototype); c.prototype.check = function () { const t = this.getIsImageComplete(); if (t) { this.confirm(this.img.naturalWidth !== 0, "naturalWidth"); return; } this.proxyImage = new Image(); this.proxyImage.addEventListener("load", this); this.proxyImage.addEventListener("error", this); this.img.addEventListener("load", this); this.img.addEventListener("error", this); this.proxyImage.src = this.img.src; }; c.prototype.getIsImageComplete = function () { return this.img.complete && this.img.naturalWidth; }; c.prototype.confirm = function (t, e) { this.isLoaded = t; this.emitEvent("progress", [this, this.img, e]); }; c.prototype.handleEvent = function (t) { const e = "on" + t.type; if (this[e]) { this[e](t); } }; c.prototype.onload = function () { this.confirm(true, "onload"); this.unbindEvents(); }; c.prototype.onerror = function () { this.confirm(false, "onerror"); this.unbindEvents(); }; c.prototype.unbindEvents = function () { this.proxyImage.removeEventListener("load", this); this.proxyImage.removeEventListener("error", this); this.img.removeEventListener("load", this); this.img.removeEventListener("error", this); }; function u (t, e) { this.url = t; this.element = e; this.img = new Image(); }u.prototype = Object.create(c.prototype); u.prototype.check = function () { this.img.addEventListener("load", this); this.img.addEventListener("error", this); this.img.src = this.url; const t = this.getIsImageComplete(); if (t) { this.confirm(this.img.naturalWidth !== 0, "naturalWidth"); this.unbindEvents(); } }; u.prototype.unbindEvents = function () { this.img.removeEventListener("load", this); this.img.removeEventListener("error", this); }; u.prototype.confirm = function (t, e) { this.isLoaded = t; this.emitEvent("progress", [this, this.element, e]); }; l.makeJQueryPlugin = function (t) { t = t || e.jQuery; if (!t) { return; }s = t; s.fn.imagesLoaded = function (t, e) { const i = new l(this, t, e); return i.jqDeferred.promise(s(this)); }; }; l.makeJQueryPlugin(); return l; });
/*!
 * Flickity imagesLoaded v2.0.0
 * enables imagesLoaded option for Flickity
 */
(function (i, n) { if (typeof define === "function" && define.amd) { define(["flickity/js/index", "imagesloaded/imagesloaded"], function (t, e) { return n(i, t, e); }); } else if (typeof module === "object" && module.exports) { module.exports = n(i, require("flickity"), require("imagesloaded")); } else { i.Flickity = n(i, i.Flickity, i.imagesLoaded); } })(window, function t (e, i, s) { "use strict"; i.createMethods.push("_createImagesLoaded"); const n = i.prototype; n._createImagesLoaded = function () { this.on("activate", this.imagesLoaded); }; n.imagesLoaded = function () { if (!this.options.imagesLoaded) { return; } const n = this; function t (t, e) { const i = n.getParentCell(e.img); n.cellSizeChange(i && i.element); if (!n.options.freeScroll) { n.positionSliderAtSelected(); } }s(this.slider).on("progress", t); }; return i; });
